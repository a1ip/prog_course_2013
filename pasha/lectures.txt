ВВЕДЕНИЕ
1) Git - обмен информацией, позволяет следить за историей изменений файлов
2) G++ - программа-компиллятор, создаёт exe-файлы из cpp (необходим mingw и msys)
3) Emax - простой универсальный тестовый редактор для c++, latex, piton, pascal, basic, …
3) Povray - создание красивых картинок
4) Qt - мощная библейотека под c++ (его необходимо устанавливать отдельно), кроссплатформенный инструментарий
5) stl - стандартная библиотека шаблонов (входит в с++), помогает решать стандартные задачи
_________________________________________________

С++ (Страуструп)

Плюсы:
1.он является компилятором - из исходного кода делает машинный код
	а) данные хранятся в регистрах процессора (add ax, bx => будет сложены ax и bx и сохранены)=> последовательность битов
	б) процессор связан с ОЗУ, в кот. хранятся послед-ти битов: посылает адрес в ОЗУ, ОЗУ присылает код операции, кот. необх. Выполнить, считывается следующий код операции и т.д.
	(интерпретатор - программа (pyton.exe) считывает из файла (print.py) последовательность кода и интерпретирует их - это замедляет работу программы)
2.он древний
	обширные библиотеки (stl,Qt,gsl), совместимость с др. языками программирования, документация (cplusplus.com), исхоженность (легко найти решение проблем в интернете), быстрота

Минусы:
1.он древний
	а) сложность: был язык C (ссылки, указатели, функции), который близок к ассемблеру, а С++ (классы, шаблоны) более высокая степень абстракции (более простой код) => замедление работы и потеря контроля работы.
	б) 4 языка внутри: Кроме C в C++ ещё есть препроцессор (#include,#define,… - подстановка блоков текста др. в др.) и язык шаблонов (template - правила подстановок текста типизированы)
	в) Выделение памяти - опасно (её нужно вернуть после использования)
_________________________________________________

Git

Бесплатный сервер от гугл: git@github.com:tarstars/prog_course_2013.git
1.	git clone git@github.com:tarstars/prog_course_2013.git
2.	ls - вывод содержания текущей папки
3.	cd dir - перейти в подпапку dir (cd=change directory)
4.	cd ..  -  на директорию вверх
5.	cd ../.. - подъём на две директории вверх
6.	mkdir tass - создать папку tass (mkdirr=make directory)
7.	emax main.cpp - создали о открыли файл main.cpp
8.	bg - отправили в фоновый режим, чтобы не блокировать консоль
9.	gitk& - вызов графического интерфеса изменений
10.	git add file.cpp - добавить свой файл
11.	git commit -m “my comment” - сохранить изменения в git, если файлы новые
12.	git commit -am “update version” - сохранить изменения в git, если файл обновлён
13.	git pull - забрать изменения из сервера
14.	git push - отправить изменения на сервер
_________________________________________________

Emacs (cheat sheet)

1.	cat main.cpp - распечатывает содержимое файла
2.	ctrl+y - вставить
3.	alt+w - копировать
4.	ctrl+x + u - отменить последнее изменение
5.	ctrl+h+f - документация по функции
6.	ctrl+h+k - документация по последовательности нажатых кнопок
7.	ctrl+x + ctrl+s - сохранить в файл
8.	ctrl+x + ctrl+c - выйти из emacx
9.	ctrl+w - вырезать
10.	ctrl+y - вставить
11.	alt+y - заменить текст предшествующим уничтоженным текстом
12.	ctrl+s - поиск вперёд
13.	ctrl+r - поиск назад
14.	g++ main.cpp -o prog  -  создаём prog.exe из main.cpp
15.	./prog  -  запуск prog.exe
16.	Alt+x + eshell - запуск shell
17.	Alt+x + compile + (g++ main.cpp -o prog)  -  компилляция
18.	Ctrl+x + влево/вправо
19.	Ctrl+j - автоматическая табуляция
20.	Alt+g+g+18- перейти на 18 строку
21.	Ctrl+x + ~  -  переход к следующей ошибке
22.	Ctrl+c + ctrl+c  -  закомментировать
23.	Ctrl+x + ctrl+e - выполнить операцию (* 1 2 3 4 5) // посчитает 5!
_________________________________________________

C++

1.	Типы данных: int, double, char, long int, float, void,
unsigned
8 4 2 1 - вес разряда
0 0 0 0  - 0
0 0 0 1  - 1
0 0 1 0  - 2
0 0 1 1  - 3 (2+1)
1 1 1 1  - 15 (8+4+2+1)  - это unsigned трактовка числа
Превращаем 8 в -8 - тогда от -8 до 7 (-2n/2 до 2n/2-1) - появился знак signed
char = signed + 8 битов => от -128 до 127

2.	Объявление и определение
int a;  - объявление = выделение памяти под int + имя для группы байтиков;
a=5; - определение = запись в память в двоичном коде;
int a=5; - объявление и определение
int *pa; (указатель на int) объявление указателя = выделение обл памяти, достаточное, чтобы хранит номер ячейки, хранящей в себе целочисленную переменную и назвали её pa.
pa=&a; где &=получение адреса переменной.
b=*pa; - взятие значения переменной, на которую указывает pa (разыменование)
int &b=a; - (ссылка) у этой области памяти появляется ещё одно имя b
//ссылку можно только одновременно объявить и определить

	В объявлении	В выражении
&	ссылка			взятие адреса; побитовое ”и”
*	указатель		умножение; взятие значения по адресу

a.cpp -> a.ob (компиляция) -> a.? (линковка) -> a.exe

побитовые операции: & - and;   | - or;
					<< - *2^ (shift);   >> - /2^ (shift);
					^ - (or, but 1^1=0); ~ - not
					
управляющие конструкции:
1) ветвление: if/else, switch/case/default
2) циклы: for, while, do {} while () (тело будет 1 раз выполнено)
3) goto

Составной оператор - {оп1; оп2; …}

Оператор запятая: выр1, выр2,… - последовательное выполнение выражений, результат = значение последнего выражение

Пример (числа фиббоначи до 100)
int a,b,c; a=1; b=1; c=a+b;
while(a=b,b=c,c=a+b,c<100) {
cout<<a<<endl;
}
или
int a,b,c; a=1; b=1; c=a+b;
while(c<100) {
a=b;b=c;c=a+b;
cout<<a<<endl;
}
или
int a,b,c;
for(a=1, b=1,c=a+b; c<100; a=b,b=c,c=a+b) {
cout<<a<<endl;
}

for(сек1; сек2; сек3) {}
Сек1-> сек2 (если false - конец) -> тело -> сек3 -> сек2 -> …


if (усл){
	оп1;
}
else{
	оп2;
}


int a;
cin>>a;
switch(a){
case 1: cout<<1; break; // break = выход из switch, continue = выполнение следующей итерации цикла
case 2: cout<<2; break;
default: cout<<3; break;
}
_________________________________________________

Массивы

int a[5]; // нумерация элементов начинается с нуля
int *pa,*pb;
pa=a; // название массива = указатель на нулевой элемент
pb=a;
pb=pa+3; // ук-ль на третий элемент
int s=(pb-pa)*sizeof(*pa); // (кол-во длин (целых) чисел)*(р-р целого в байтах)
*(pa+2)=10; // присвоение второму эл-ту значения 10
pa[2]=10; // то же самое
_________________________________________________

Функции

Регистр адреса команд - записывается, где мы сейчас находимся
Регистр значений переменных
Поэтому в памяти выделен ещё кусочек (стек вызова функций), а в процессоре - ещё регистр стека (чтобы можно было восстановить значения, которые были до вызова функции)

int a=f(5)*g(6)+h(7); //* - более приоритетно => f,g , а только потом h
int f(int x) {
val=…;
return val;
}

1) передавать арг-т по ссыле
2) п-ть арг-т по указателю
3) глобальные переменные
3) вернуть объект класса структура


int a=5;
f(a); //int &x=a; - второе имя
cout<<a;
void f(int &x) {
	x=100; // меняем значение x, а следовательно и а
}
// если   void f(int x), то будет создана переменная x, кот. живёт только в f, поэтому а не изменится

// если  f(&a); void f(int *px){*px=100;}, то будет создан указатель px, кот. указывает на а, поэтому а изменится

По ссылке - лучше, т.к. не плодим ничего лишнего и тяжело порушить программу
По указателю - лучше, т.к. по виду можно узнать будем менять аргумент а или нет и можно проверить указатель на ноль (детектируем мусор)

// возвращаем только 1 значение => используем стуктуру
struct pos{int x,y;}
pos pfunc(int a, int b) {
	pos ret;
ret.x=a; ret.y=b;
return ret;
}


int a=5; //целое
int *pa, *pb; //указатели на целое
pa=&a; // взятие адреса
int &b=a; // новое имя для a
int* &c=pa // новое имя для указателя pa
a>>b; // b/(2^a)  ??

Операция ++
					a++		++a
Значение выражения	a		a+1
Значение переменной	a+1		a+1
a++ - дороже по памяти!!
a+=1;
a++;
++a;
a=a+1;
a%=b; // остаток от деления a на b

поэлементное считывание входного потока
while(cin>>x){
	cout<<x<<” ”;
}
Вход: 1 2.0 \n
Считали до пробела,энтера или табулядии , записали в х; потом х будет перезаписываться

prog.exe<a.txt>b.txt - (из командной строки) считываем из а.txt, запись в b.txt

while(cin>>x>>y){ //считываем по два числа через пробел
	cout<<xy<<” ”;
}
_________________________________________________

Массивы

#include <vector>
using namespace std;
vector<double> dat; // одномерный массив
dat.push_back(5.0); //добавить элемент (5.0) в конец массива dat

void print(vector<double>& dat){
	for(int i=0; i<=(int)dat.size(); ++i){   //size - метод для данного класса
		cout<<arr[i]<<” “;
	}
}


int n;
cin>>n;
vector<double> dat(n); ..//если тип вместо класса (double), то заполняется по-умолчанию мусором
vector<double> dat(n,a); // все n элементов будут равны а
double *pd = &(dat[5]); //указатель на пятый элемент


Итератор - обобщение указателя - тип внутри класса vector
vector<double>::iterator itb= dat.begin(); // ук-ль на нулевой эл-т из dat
vector<double>::iterator ite= dat.end(); // ук-ль на элемент за последним
b=*itb; // взятие значения


voit print1(vector<double>::iterator it, int n){
	for(int i=0; i<n; ++i){
cout<<*it<<” ”;
		++it;
	}
}
print1(itb, dat,size());

voit print2(vector<double>::iterator itb, vector<double>::iterator ite){
	while(itb<ite){
		cout<<*(itb++)<<” “;
	}
}
print2(dat.begin, dat.end);
_________________________________________________

Наибольший общий делитель (НОД) (метод Евклида)
a,b , c=остаток от деления a/b, d= остаток от деления b/c, …, НОД, 0
a=b*q0+r0			r(0)=alpha*a+beta*b  (alpha,beta - целые)
b=r0*q1+r1			r(1)=alpha1*a+beta1*b
r(n)=qn*r_(n+1)+0;	r_(n+1)=alpha*a+beta*b=НОД(a,b)
a,b - взаимно простые => НОД=1

a*p+b*q=nod(ab)
a=b*q0+r0	=>	r0=a0*a+b0*b
b=r0*q1+r1	=>	r1=a1*a+b1*b
r0=r1*q2+r2	=>
			=>	rn=an*a+bn*b

Длительность работы метода Евклида
r(n)=1; // т.к. взаимно простые
q(i)=1; чтобы макс длительность
=> r(n-1)=1; r(n-2)=r(n-1)+r(n) - а это фиббоначи

a(n)=t^n;
a(n+2)=a(n+1)+a(n)
t^(n+2)=t^(n+1)+t^n		=>	((1+sqrt(5))/2)^n=1.618^n ~=a,b => n=
 a,b - соседние числа фиббоначи => очень долго


Опредениение НОД методом деление пополам
(бинарный алгоритм Евклида)
nod(2n,2m)=2nod(n,m)
nod(2m, 2n+1)=nod(m,2n+1)
nod(m,n)=nod(m-n,n)

40902,24140,	nod=d
20451,12070,	d1=d/(2^k)=d/2,k=1
20451,6035,		d1
6035,1446,		d1
6035,723,		d1
5312,723,		d1
A,0,			dn=A*2^h (h=1-степени, которые накопились)
_________________________________________________

Инвариант - утверждение, кот. выполняется по ходу работы программы, а по окончании даёт решение задачи.

Рекурсия
	1) n!: f(0)=1; f(n)=n*f(n-1)
	2) фиббоначи: g(0)=0; g(1)=1; g(n)=g(n-1)+g(n-2);
	3) биномиальные коэффициенты
	4) quick sort
	5) поиск по дереву
	6) три (a,b,y) ханойские башни:
		a+b+y=1+2+3=6  => y=…
		f(a,b,1): cout<<a<<”->”<<b<<endl;
		f(a,b,n): f(a,y,n-1) f(a,b,1) f(y,b,n-1)

Ход рекурсии на прмере факториала:
3!: main->f(3)->f(2)->f(1)->f(0)->f(1)*f(0)->…

Треугольник паскаля (4,1)=?:
	main	->(3,0)=1
			->(3,1)	->(2,0)=1
					->(2,1)->…
	В итоге получается перевернутый тр.П-ля по вызовам (много!)
_________________________________________________

int main(int argc, char* argv[])
int main(int argc, char** argv)
argc - кол-во слов в вызове программы
./prog a.txt b.txt //argc=3
argv - ячейка из нескольких элементов, в кот. хранится указатель на строку

int main(int argc, char* argv[]){
	for(int i=0; i<argc; ++i){
		cout<<argv[i]<<endl; // распечатываем имена своих аргументов
}
}


#include <fstream>
#include <iostream>
using namespace std;
int main(int argc, char* argv[]){
	if(argc==1){
		cerr<<"error"<<endl;
		return 1;
	}
	ofstream dest(argv[1]); // открыли доступ к первому файлу //./prog a.txt
	for(int i=1; i<2000; i*=2){
		dest<<i<<endl; //идёт запись в a.txt
	}
	return 0;
}
_________________________________________________

Задание горячей кнопки для Emacs

(global-set-key '[f7]' (lambda ()
							(interactive)
							(compile “g++ main -o prog”)))
_________________________________________________

Программа make (linux) или mingw32-make (windows)

Makefile
	цель: зависимость1, з-ть2, 3-ть3
	  /t  команда	(/t - табуляция)
Получаем цель с помощью команды по зависимостям 1,2,3…
g++ main.cpp -c - 		создание объектного файла
g++ main.o b.o -o prog - создаём ехе из объектных файлов

Makefile (файл):
prog: a.o b.o
	g++ a.o b.o -o prog
a.o: a.cpp
	g++ a.cpp -c
b.o: b.cpp
	g++ b.cpp -c

далее mingw32-make для обновления всей программы и пересобирание ехе


файлы a.txt (1 2 5 7 5), b.txt (10 20 50 60 40), c.txt (500 100 1 12 2) с числами
f=a*b+c:	a*b->d1.txt + c->f.txt
mult - перемножает файлы
plus - скадывает файлы


ОТЛАДКА
________________________
Makefile:
# make prog_ura => выполнится только одно правило

all_targets: prog_simple prog_ku porg_ura prog_ura_ku

prog_simple: main.cpp
	g++ main.cpp -o prog
	
prog_ku: main.cpp
	g++ main.cpp -o progk -DKU
	
prog_ura: main.cpp
	g++ main.cpp -o progu -DURA
	
prog_ku_ura: main.cpp
	g++ main.cpp -o progku -DKU -DURA
___________________________
main.cpp:

#include<iostream>
using namespace std;
int main() {
	#ifdef KU	//выполняется до начала компиляции
				//если определён KU, то выполняем ...
				//-Dwww => следующий символ (www) определён
	cout<<"ku"<<endl;
	#endif
	
	#ifdef URA
	cout<<"ura!"<<endl;
	#endif
}

______________________________________________________________

Комплексные числа


Простая программа:

double ax,ay,bx,by,cx,cy; //global

void complex_add(){
	cx=ax+bx;
	cy=ay+by;
}

int main(){
	ax=3; ay=4; bx=7; by=5;
	complex_add();
}
____________________

Более сложная программа с классами
(хотим копии этих констукций и ограничить область глобальности)

class Complex {
	double x,y; //видны из всех методов данного класса
public:
// 	Complex(double xx, double yy) {
//		x=xx;
//		y=yy;
//	}

// 	Complex(double x, double y) {
//		this -> x=x;
//		this -> y=y;
//	}

	Complex(double xx, double yy): x(xx), y(yy) {
	}
	
	Complex(): x(0), y(0) {
	}
	
	double abs() {return sqrt(x*x + y*y);}
	
	void print(ostream& os){
		os<<"("<<x<<","<<y<<")"<<endl;
	}
	
//	friend ostream& operator<<(ostream& , const Complex&);

	operator>>(ostream& os) const{
		return os<<"("<<x<<","<<y<<")"<<endl;
	}

	operator<<(ostream& os, const Complex& r){
		return r>>os; //меняем арг местами и обращаемся к >>
	}
	
	Complex operator+(const Complex& r) const{
		return Complex(x+r.x, y+r.y)
};

//	ostream&
//	operator<<(ostream& os, const Complex& r){
//		return os<<"("<<r.x<<","<<r.y<<")"<<endl;
//	}

int main() {
	Complex tt, alpha(3,4), beta(10,20), gamma;
	tt.x=5; //неправильно!!!, т.к. x э private (т.е. скрыт=инкапсуляция)
	cout<<"abs="<<alpha.abs()<<endl;
	alpha.print(cout);
	
	cout<<alpha<<endl;	//эти две строчкиэквивалентны
	operator<<(cout,alpha);
	
	alpha.operator>>(cout); //если >> определён внутри класса (как print)
	alpha >> cout;
	alpha >> (cout<<"when alpha=")<<"the weather is good<<endl;
	
	gamma=alpha+beta;
//	gamma=alpha.operator+(beta);
	cout<<alpha<<"+"<<beta<<"="<<gamma<<endl;
}
____________________________________________________________________________

Класс массивов

class OurArray{
	int n;
	double *pDat;
public:
	OurArray(int nn): n(nn){
		pDat=new double[n];
	}
	
	OurArray(cons &OurArray r){	//копирующий конструктор
		n=r.n;
		pDat=new double[r.n];
		for(int i=0; i<r.n; ++i){
			pDat[i]=r.pDat;
		}
	}
	
	double& at(int ind) {return pDat[ind];}
	
	ostream& print(ostream& os) const{
		for(int i=0; i<n; ++i){
			os<<pDat[i]<<" ";
		}
	}
	
	~OurArray() {delete []pDat;}
};

int main(){
	OurArray x(10);
	x.at(3)=4;
	OurArray y=x; //вызов копирующего конструктора
	x.print(cout)<<endl;
	
	OurArray z(10);
	z=x;	//ошибка -> д.з. (исправить)
}