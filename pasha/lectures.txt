переменная среды:	QMAKESPEC
значение:			win32-g++

D:\Programs (need to install)\fftw-3.3.3\fftw-3.3.3\api
copy .h files to C:\work\Desktop\Qt\4.8.1\mingw\include

D:\Programs (need to install)\fftw-3.3.3-dll32
copy all to C:\work\Desktop\Qt\4.8.1\mingw\lib

ВВЕДЕНИЕ
1) Git - обмен информацией, позволяет следить за историей изменений файлов
2) G++ - программа-компиллятор, создаёт exe-файлы из cpp (необходим mingw и msys)
3) Emax - простой универсальный тестовый редактор для c++, latex, piton, pascal, basic, …
3) Povray - создание красивых картинок
4) Qt - мощная библейотека под c++ (его необходимо устанавливать отдельно), кроссплатформенный инструментарий
5) stl - стандартная библиотека шаблонов (входит в с++), помогает решать стандартные задачи
_________________________________________________

С++ (Страуструп)

Плюсы:
1.он является компилятором - из исходного кода делает машинный код
	а) данные хранятся в регистрах процессора (add ax, bx => будет сложены ax и bx и сохранены)=> последовательность битов
	б) процессор связан с ОЗУ, в кот. хранятся послед-ти битов: посылает адрес в ОЗУ, ОЗУ присылает код операции, кот. необх. Выполнить, считывается следующий код операции и т.д.
	(интерпретатор - программа (pyton.exe) считывает из файла (print.py) последовательность кода и интерпретирует их - это замедляет работу программы)
2.он древний
	обширные библиотеки (stl,Qt,gsl), совместимость с др. языками программирования, документация (cplusplus.com), исхоженность (легко найти решение проблем в интернете), быстрота

Минусы:
1.он древний
	а) сложность: был язык C (ссылки, указатели, функции), который близок к ассемблеру, а С++ (классы, шаблоны) более высокая степень абстракции (более простой код) => замедление работы и потеря контроля работы.
	б) 4 языка внутри: Кроме C в C++ ещё есть препроцессор (#include,#define,… - подстановка блоков текста др. в др.) и язык шаблонов (template - правила подстановок текста типизированы)
	в) Выделение памяти - опасно (её нужно вернуть после использования)
_________________________________________________

Git

Бесплатный сервер от гугл: git@github.com:tarstars/prog_course_2013.git
1.	git clone git@github.com:tarstars/prog_course_2013.git
2.	ls - вывод содержания текущей папки
3.	cd dir - перейти в подпапку dir (cd=change directory)
4.	cd ..  -  на директорию вверх
5.	cd ../.. - подъём на две директории вверх
6.	mkdir tass - создать папку tass (mkdirr=make directory)
7.	emax main.cpp - создали о открыли файл main.cpp
8.	bg - отправили в фоновый режим, чтобы не блокировать консоль
9.	gitk& - вызов графического интерфеса изменений
10.	git add file.cpp - добавить свой файл
11.	git commit -m “my comment” - сохранить изменения в git, если файлы новые
12.	git commit -am “update version” - сохранить изменения в git, если файл обновлён
13.	git pull - забрать изменения из сервера
14.	git push - отправить изменения на сервер
_________________________________________________

Emacs (cheat sheet)

1.	cat main.cpp - распечатывает содержимое файла
2.	ctrl+y - вставить
3.	alt+w - копировать
4.	ctrl+x + u - отменить последнее изменение
5.	ctrl+h+f - документация по функции
6.	ctrl+h+k - документация по последовательности нажатых кнопок
7.	ctrl+x + ctrl+s - сохранить в файл
8.	ctrl+x + ctrl+c - выйти из emacx
9.	ctrl+w - вырезать
10.	ctrl+y - вставить
11.	alt+y - заменить текст предшествующим уничтоженным текстом
12.	ctrl+s - поиск вперёд
13.	ctrl+r - поиск назад
14.	g++ main.cpp -o prog  -  создаём prog.exe из main.cpp
15.	./prog  -  запуск prog.exe
16.	Alt+x + eshell - запуск shell
17.	Alt+x + compile + (g++ main.cpp -o prog)  -  компилляция
18.	Ctrl+x + влево/вправо
19.	Ctrl+j - автоматическая табуляция
20.	Alt+g+g+18- перейти на 18 строку
21.	Ctrl+x + ~  -  переход к следующей ошибке
22.	Ctrl+c + ctrl+c  -  закомментировать
23.	Ctrl+x + ctrl+e - выполнить операцию (* 1 2 3 4 5) // посчитает 5!
_________________________________________________

C++

1.	Типы данных: int, double, char, long int, float, void,
unsigned
8 4 2 1 - вес разряда
0 0 0 0  - 0
0 0 0 1  - 1
0 0 1 0  - 2
0 0 1 1  - 3 (2+1)
1 1 1 1  - 15 (8+4+2+1)  - это unsigned трактовка числа
Превращаем 8 в -8 - тогда от -8 до 7 (-2n/2 до 2n/2-1) - появился знак signed
char = signed + 8 битов => от -128 до 127

2.	Объявление и определение
int a;  - объявление = выделение памяти под int + имя для группы байтиков;
a=5; - определение = запись в память в двоичном коде;
int a=5; - объявление и определение
int *pa; (указатель на int) объявление указателя = выделение обл памяти, достаточное, чтобы хранит номер ячейки, хранящей в себе целочисленную переменную и назвали её pa.
pa=&a; где &=получение адреса переменной.
b=*pa; - взятие значения переменной, на которую указывает pa (разыменование)
int &b=a; - (ссылка) у этой области памяти появляется ещё одно имя b
//ссылку можно только одновременно объявить и определить

	В объявлении	В выражении
&	ссылка			взятие адреса; побитовое ”и”
*	указатель		умножение; взятие значения по адресу

a.cpp -> a.ob (компиляция) -> a.? (линковка) -> a.exe

побитовые операции: & - and;   | - or;
					<< - *2^ (shift);   >> - /2^ (shift);
					^ - (or, but 1^1=0); ~ - not
					
управляющие конструкции:
1) ветвление: if/else, switch/case/default
2) циклы: for, while, do {} while () (тело будет 1 раз выполнено)
3) goto

Составной оператор - {оп1; оп2; …}

Оператор запятая: выр1, выр2,… - последовательное выполнение выражений, результат = значение последнего выражение

Пример (числа фиббоначи до 100)
int a,b,c; a=1; b=1; c=a+b;
while(a=b,b=c,c=a+b,c<100) {
cout<<a<<endl;
}
или
int a,b,c; a=1; b=1; c=a+b;
while(c<100) {
a=b;b=c;c=a+b;
cout<<a<<endl;
}
или
int a,b,c;
for(a=1, b=1,c=a+b; c<100; a=b,b=c,c=a+b) {
cout<<a<<endl;
}

for(сек1; сек2; сек3) {}
Сек1-> сек2 (если false - конец) -> тело -> сек3 -> сек2 -> …


if (усл){
	оп1;
}
else{
	оп2;
}


int a;
cin>>a;
switch(a){
case 1: cout<<1; break; // break = выход из switch, continue = выполнение следующей итерации цикла
case 2: cout<<2; break;
default: cout<<3; break;
}
_________________________________________________

Массивы

int a[5]; // нумерация элементов начинается с нуля
int *pa,*pb;
pa=a; // название массива = указатель на нулевой элемент
pb=a;
pb=pa+3; // ук-ль на третий элемент
int s=(pb-pa)*sizeof(*pa); // (кол-во длин (целых) чисел)*(р-р целого в байтах)
*(pa+2)=10; // присвоение второму эл-ту значения 10
pa[2]=10; // то же самое
_________________________________________________

Функции

Регистр адреса команд - записывается, где мы сейчас находимся
Регистр значений переменных
Поэтому в памяти выделен ещё кусочек (стек вызова функций), а в процессоре - ещё регистр стека (чтобы можно было восстановить значения, которые были до вызова функции)

int a=f(5)*g(6)+h(7); //* - более приоритетно => f,g , а только потом h
int f(int x) {
val=…;
return val;
}

1) передавать арг-т по ссыле
2) п-ть арг-т по указателю
3) глобальные переменные
3) вернуть объект класса структура


int a=5;
f(a); //int &x=a; - второе имя
cout<<a;
void f(int &x) {
	x=100; // меняем значение x, а следовательно и а
}
// если   void f(int x), то будет создана переменная x, кот. живёт только в f, поэтому а не изменится

// если  f(&a); void f(int *px){*px=100;}, то будет создан указатель px, кот. указывает на а, поэтому а изменится

По ссылке - лучше, т.к. не плодим ничего лишнего и тяжело порушить программу
По указателю - лучше, т.к. по виду можно узнать будем менять аргумент а или нет и можно проверить указатель на ноль (детектируем мусор)

// возвращаем только 1 значение => используем стуктуру
struct pos{int x,y;}
pos pfunc(int a, int b) {
	pos ret;
ret.x=a; ret.y=b;
return ret;
}


int a=5; //целое
int *pa, *pb; //указатели на целое
pa=&a; // взятие адреса
int &b=a; // новое имя для a
int* &c=pa // новое имя для указателя pa
a>>b; // b/(2^a)  ??

Операция ++
					a++		++a
Значение выражения	a		a+1
Значение переменной	a+1		a+1
a++ - дороже по памяти!!
a+=1;
a++;
++a;
a=a+1;
a%=b; // остаток от деления a на b

поэлементное считывание входного потока
while(cin>>x){
	cout<<x<<” ”;
}
Вход: 1 2.0 \n
Считали до пробела,энтера или табулядии , записали в х; потом х будет перезаписываться

prog.exe<a.txt>b.txt - (из командной строки) считываем из а.txt, запись в b.txt

while(cin>>x>>y){ //считываем по два числа через пробел
	cout<<xy<<” ”;
}
_________________________________________________

Массивы

#include <vector>
using namespace std;
vector<double> dat; // одномерный массив
dat.push_back(5.0); //добавить элемент (5.0) в конец массива dat

void print(vector<double>& dat){
	for(int i=0; i<=(int)dat.size(); ++i){   //size - метод для данного класса
		cout<<arr[i]<<” “;
	}
}


int n;
cin>>n;
vector<double> dat(n); ..//если тип вместо класса (double), то заполняется по-умолчанию мусором
vector<double> dat(n,a); // все n элементов будут равны а
double *pd = &(dat[5]); //указатель на пятый элемент


Итератор - обобщение указателя - тип внутри класса vector
vector<double>::iterator itb= dat.begin(); // ук-ль на нулевой эл-т из dat
vector<double>::iterator ite= dat.end(); // ук-ль на элемент за последним
b=*itb; // взятие значения


voit print1(vector<double>::iterator it, int n){
	for(int i=0; i<n; ++i){
cout<<*it<<” ”;
		++it;
	}
}
print1(itb, dat,size());

voit print2(vector<double>::iterator itb, vector<double>::iterator ite){
	while(itb<ite){
		cout<<*(itb++)<<” “;
	}
}
print2(dat.begin, dat.end);
_________________________________________________

Наибольший общий делитель (НОД) (метод Евклида)
a,b , c=остаток от деления a/b, d= остаток от деления b/c, …, НОД, 0
a=b*q0+r0			r(0)=alpha*a+beta*b  (alpha,beta - целые)
b=r0*q1+r1			r(1)=alpha1*a+beta1*b
r(n)=qn*r_(n+1)+0;	r_(n+1)=alpha*a+beta*b=НОД(a,b)
a,b - взаимно простые => НОД=1

a*p+b*q=nod(ab)
a=b*q0+r0	=>	r0=a0*a+b0*b
b=r0*q1+r1	=>	r1=a1*a+b1*b
r0=r1*q2+r2	=>
			=>	rn=an*a+bn*b

Длительность работы метода Евклида
r(n)=1; // т.к. взаимно простые
q(i)=1; чтобы макс длительность
=> r(n-1)=1; r(n-2)=r(n-1)+r(n) - а это фиббоначи

a(n)=t^n;
a(n+2)=a(n+1)+a(n)
t^(n+2)=t^(n+1)+t^n		=>	((1+sqrt(5))/2)^n=1.618^n ~=a,b => n=
 a,b - соседние числа фиббоначи => очень долго


Опредениение НОД методом деление пополам
(бинарный алгоритм Евклида)
nod(2n,2m)=2nod(n,m)
nod(2m, 2n+1)=nod(m,2n+1)
nod(m,n)=nod(m-n,n)

40902,24140,	nod=d
20451,12070,	d1=d/(2^k)=d/2,k=1
20451,6035,		d1
6035,1446,		d1
6035,723,		d1
5312,723,		d1
A,0,			dn=A*2^h (h=1-степени, которые накопились)
_________________________________________________

Инвариант - утверждение, кот. выполняется по ходу работы программы, а по окончании даёт решение задачи.

Рекурсия
	1) n!: f(0)=1; f(n)=n*f(n-1)
	2) фиббоначи: g(0)=0; g(1)=1; g(n)=g(n-1)+g(n-2);
	3) биномиальные коэффициенты
	4) quick sort
	5) поиск по дереву
	6) три (a,b,y) ханойские башни:
		a+b+y=1+2+3=6  => y=…
		f(a,b,1): cout<<a<<”->”<<b<<endl;
		f(a,b,n): f(a,y,n-1) f(a,b,1) f(y,b,n-1)

Ход рекурсии на прмере факториала:
3!: main->f(3)->f(2)->f(1)->f(0)->f(1)*f(0)->…

Треугольник паскаля (4,1)=?:
	main	->(3,0)=1
			->(3,1)	->(2,0)=1
					->(2,1)->…
	В итоге получается перевернутый тр.П-ля по вызовам (много!)
_________________________________________________

int main(int argc, char* argv[])
int main(int argc, char** argv)
argc - кол-во слов в вызове программы
./prog a.txt b.txt //argc=3
argv - ячейка из нескольких элементов, в кот. хранится указатель на строку

int main(int argc, char* argv[]){
	for(int i=0; i<argc; ++i){
		cout<<argv[i]<<endl; // распечатываем имена своих аргументов
}
}


#include <fstream>
#include <iostream>
using namespace std;
int main(int argc, char* argv[]){
	if(argc==1){
		cerr<<"error"<<endl;
		return 1;
	}
	ofstream dest(argv[1]); // открыли доступ к первому файлу //./prog a.txt
	for(int i=1; i<2000; i*=2){
		dest<<i<<endl; //идёт запись в a.txt
	}
	return 0;
}
_________________________________________________

Задание горячей кнопки для Emacs

(global-set-key '[f7]' (lambda ()
							(interactive)
							(compile “g++ main -o prog”)))
_________________________________________________

Программа make (linux) или mingw32-make (windows)

Makefile
	цель: зависимость1, з-ть2, 3-ть3
	  /t  команда	(/t - табуляция)
Получаем цель с помощью команды по зависимостям 1,2,3…
g++ main.cpp -c - 		создание объектного файла
g++ main.o b.o -o prog - создаём ехе из объектных файлов

Makefile (файл):
prog: a.o b.o
	g++ a.o b.o -o prog
a.o: a.cpp
	g++ a.cpp -c
b.o: b.cpp
	g++ b.cpp -c

далее mingw32-make для обновления всей программы и пересобирание ехе


файлы a.txt (1 2 5 7 5), b.txt (10 20 50 60 40), c.txt (500 100 1 12 2) с числами
f=a*b+c:	a*b->d1.txt + c->f.txt
mult - перемножает файлы
plus - скадывает файлы


ОТЛАДКА
________________________
Makefile:
# make prog_ura => выполнится только одно правило

all_targets: prog_simple prog_ku porg_ura prog_ura_ku

prog_simple: main.cpp
	g++ main.cpp -o prog
	
prog_ku: main.cpp
	g++ main.cpp -o progk -DKU
	
prog_ura: main.cpp
	g++ main.cpp -o progu -DURA
	
prog_ku_ura: main.cpp
	g++ main.cpp -o progku -DKU -DURA
___________________________
main.cpp:

#include<iostream>
using namespace std;
int main() {
	#ifdef KU	//выполняется до начала компиляции
				//если определён KU, то выполняем ...
				//-Dwww => следующий символ (www) определён
	cout<<"ku"<<endl;
	#endif
	
	#ifdef URA
	cout<<"ura!"<<endl;
	#endif
}

______________________________________________________________

Комплексные числа


Простая программа:

double ax,ay,bx,by,cx,cy; //global

void complex_add(){
	cx=ax+bx;
	cy=ay+by;
}

int main(){
	ax=3; ay=4; bx=7; by=5;
	complex_add();
}
____________________

Более сложная программа с классами
(хотим копии этих констукций и ограничить область глобальности)

class Complex {
	double x,y; //видны из всех методов данного класса
public:
// 	Complex(double xx, double yy) {
//		x=xx;
//		y=yy;
//	}

// 	Complex(double x, double y) {
//		this -> x=x;
//		this -> y=y;
//	}

	Complex(double xx, double yy): x(xx), y(yy) {
	}
	
	Complex(): x(0), y(0) {
	}
	
	double abs() {return sqrt(x*x + y*y);}
	
	void print(ostream& os){
		os<<"("<<x<<","<<y<<")"<<endl;
	}
	
//	friend ostream& operator<<(ostream& , const Complex&);

	operator>>(ostream& os) const{
		return os<<"("<<x<<","<<y<<")"<<endl;
	}

	operator<<(ostream& os, const Complex& r){
		return r>>os; //меняем арг местами и обращаемся к >>
	}
	
	Complex operator+(const Complex& r) const{
		return Complex(x+r.x, y+r.y);
};

//	ostream&
//	operator<<(ostream& os, const Complex& r){
//		return os<<"("<<r.x<<","<<r.y<<")"<<endl;
//	}

int main() {
	Complex tt, alpha(3,4), beta(10,20), gamma;
	tt.x=5; //неправильно!!!, т.к. x э private (т.е. скрыт=инкапсуляция)
	cout<<"abs="<<alpha.abs()<<endl;
	alpha.print(cout);
	
	cout<<alpha<<endl;	//эти две строчкиэквивалентны
	operator<<(cout,alpha);
	
	alpha.operator>>(cout); //если >> определён внутри класса (как print)
	alpha >> cout;
	alpha >> (cout<<"when alpha=")<<"the weather is good<<endl;
	
	gamma=alpha+beta;
//	gamma=alpha.operator+(beta);
	cout<<alpha<<"+"<<beta<<"="<<gamma<<endl;
}
____________________________________________________________________________

Класс массивов

#include <utility> //ф-ия swap

class OurArray{
	int n;
	double *pDat;
public:
	OurArray(int nn): n(nn) {
		pDat=new double[n];
	}
	
	OurArray(const &OurArray r) {	//копирующий конструктор
		n=r.n;
		pDat=new double[r.n];
		for(int i=0; i<r.n; ++i) {
			pDat[i]=r.pDat[i];
		}
	}
	
	void swap(OurArray& r) {
		::swap(n, r.n); //меняет местами аргументы
		::swap(pDat, r.pDat);
	}
	
	OurArray& operator= (const OurArray& r) {
		/*if(this==&r) {return *this;}
		n=r.n;
		delete []pDat; //удаляем память, в которой лежали значения исходного массива
		pDat=new double[r.n]; //выделяем память нужного размера
		for(int i=0; i<r.n; ++i) {
			pDat[i]=r.pDat[i];
		}*/
		
		OurArray tmp(r); //временный объект, в кот. копируется r
		tmp.swap(*this); //данный объект <-> (tmp=r) , tmp=дан.об.(old) потом удалится
		
		return *this;
	}
	
	double& at(int ind) {return pDat[ind];}
	//double& - ссылка на эл-т => можем его задавать
	
	ostream& print(ostream& os) const{
		for(int i=0; i<n; ++i) {
			os<<pDat[i]<<" ";
		}
		return os; //чтобы можно было: x.print(cout)<<" - value of x"<<endl;
	}
	
	~OurArray() {delete []pDat;}
};

int main(){
	OurArray x(10);
	x.at(3)=4;
	OurArray y=x; //вызов копирующего конструктора
	x.print(cout)<<endl;
	
	OurArray z(10);
	z=x;	//два указателя на одно место => дважды нужно освободить
			//также появится обл. памяти, на кот. ничего не указывает
}

____________________________________________________________________

vector<int> dat;
int val;
while(cin>>val) {
	dat.push_back(val);
}
____________________________________________________________________

Класс робота, ходящего по полю и
принимающего макс. значение, на которое он вставал

запуск по команде: mingw32-make
_______________________________

Makefile:

robots: main.o robot.o
	g++ main.o robot.o field.o -o robots

main.o: main.cpp robot.h field.h
	g++ -c main.cpp
	
robot.o: robot.cpp robot.h
	g++ -c robot.cpp
	
field.o: field.cpp field.h
	g++ -c field.cpp
_______________________

main.cpp:

#include <iostream>
#include "robot.h"
#include "field.h"
using namespace std;

int main() {
	Robot bob;
	Field fld(20);
	char c;
	while(cin>>c) {
		switch(c) {
			case "w": bob.up(); break;
			case "a": bob.left(); break;
			case "s": bob.down(); break;
			case "d": bob.right(); break;
		}
		fld.print(cout, bob);
	}
	return 0;
}
_______________________

field.h:

#ifndef _FIELD_
#define _FIELD_

#include <string>

class Robot;

class Field {
	int n;
	std::string dat;
public:
	Field(int nn);
	char& at(int,int);
	viod print(std ostream&, const Robot&);
};
#endif
_______________________

field.cpp:

#include <iostream>
#include "field.h"
using namespace std;

Field::Field(int nn): n(nn), dat(n*n, '.') {}

char&
Field::at(int p, int q) {
	return dat[p*n+q]; //линейное представление двумерного массива
}

void Field::
print(std ostream& os, const Robot& r) {
	//направление изменения p,q в циклах
	//are_you_here(p,q)
	//Robot::get_symb()
}
_______________________
robot.h:

#ifndef _ROBOT_	 //
#define _ROBOT_	//=>в программу можно войти только 1 раз
#include <iostream>

class Robot {
	int x,y, n;
public:
	Robot();
	
	void right();
	void left();
	void up();
	void down();
	
	friend std::ostream& operator<< (std::ostream&, const Robot&);
};

#endif
_______________________

robot.cpp:

#include "robot.h"
#using namespace std;

Robot::Robot(): x(3), y(3), n(0) {}

ostream&
operator<< (ostream &os, const Robot &r) {
	return os<<r.x<<", "<<r.y;
}

void Robot::right() {
	++x;
}

void Robot::left() {
	--x;
}

void Robot::up() {
	++y;
}

void Robot::down() {
	--y;
}
____________________________________________________________________

Работа с qmake для генерации Makefile.

1) 1 раз в самом начале: 				qmake -project
2) из .pro файла пересоздать Makefile:	qmake
3) пересобрать проект: 					mingw32-make
4) убрать лишнее:						mingw32-make clean
____________________________________________________________________

ШАБЛОНЫ (template)
	1)генерация набора ф-ий или классов, отличающихся только типом
	2)вычисление на этапе компиляции

//сложение двух эл-тов	
template<typename T>
T sum(T x, T y) {
	return x+y;
}

template<typename T>
class coolarr { 		//семейство классов
	T *p;
public:
	coolarr(int n): p(new T[n]) {}
};

template<int n>
int fact() {
	return n*fact<n-1 //считается на этапе компиляции !!!
}

______________________________________________________________

рисуем картинки :)

#include <QImage>
#include <cmath>
#include <sstream>
using namespace std;

int main(int, char**) {
	int n=300;
	for(int k=0; k<240; ++k) {
		QImage sam(n, n, QImage::Format_ARGB32_Premultiplied);
		for(int p=0; p<n; ++p) {
			for(int q=0; q<n; ++q) {
				double dx=q-n/2, dy=p-n/2;
				double r=sqrt(dx*dx+dy*dy);
				double v=sin(r/10 - double(k)/240*3*(2*M_PI));
				double vv=255*(1+v)/2;
				int val=int(vv);
				sam.setPixel(q,p, qRgb(val,val,val)); //0<val<255;
			}
		}
		stringstream dest;
		dest<<k<<"a.jpg";
		sam.save(dest.str().c_str());
	}
	return 0;
}
________________________________________________________________
FT - n^2 сложений и умножений

если длина массива кратна d_i => работаю с кусками => n*(d_1+...+d_s)~=n*log(n)
FFTW - сишная библиотека для быстрого преобразования фурье
много способов осуществления, зависящие от архитектуры машины
поэтому нужно выбрать лучший способ (план) - ресурсоемко

в pro файл добавить (не работает!!!)
LIBS += -lfftw3 -Lc://work//Desktop//Qt//4.8.1//mingw//include//


FFTW Plan
	конструктор (две м-цы и направление)
	execute

FFTW Matrix a=load_matrix("a.bmp"), b=load_matrix("b.bmp"); //внешняя ф-ия
//имя->qimage->w,h->fftw matrix->заполняем м-цу->сохраняем
int w=a.width();
int h=a.height();
FFTW Matrix ss(h,w), ds(h,w); //конструктор
FFTW plan ps(ss,ds,FFTW_FORWARD);
ss.take_from(a); //перенос данных=копирование
ps.execute();
FFTW Matrix af.take_from(ds);
ss.take_from(b);
ps.execute();
FFTW Matrix bf.take_from(ds);
FFTW Matrix cf=mult(af,bf);
sb,db
c=...
save_matrix //создаём картинку

a.bmp		b.bmp
	F		F
	af		bf
		F-1
		c.bmp