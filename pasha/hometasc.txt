g++ main.cpp -o prog
./prog
prog.exe<a.txt>b.txt

1. 1.3.2-5; 2.3.1,3-8,10; 2.4.*; 3.2.1-5; 3.3.*, 3.4.*
2. 1)вывести геом прогресию с знаменателем 2, b0=1, до 2000 (while или for!)
   
   2)заполнить массив из n+k элементов n единичками и k ноликами
	// const int n=5; const int k=3; int a[n+k];...
	[00000111]
	create_array(int*, int n, int k)
   3) распечастка массива print(int *pa, int sz) или
      print(int *pb, int *pe) // ре - на эл-т после последнего эл-та массива
      (легко вычисляется длина, как разница)
   4*)перебрать все сочетания числа в двоичной системе,
     реализовав операцию bool next(int *pb, int *pe) (следующее значение в двоичной системе)
     (каждое следующее больше предыдущего)
   5*)сдвинуть эл-ты массива на k позиций (по кругу) (а)создавать второй массив; б)не ...)
     но можно создавать много переменных
   6)заменить в массиве эл-ты на сумму соседних эл-тов
     (крайние эл-ты не трогать) (а)создавать второй массив; б)не ...)
   
   7)вывести двоичное представление введённого числа

   int a[]={0,0,0,1};
	int *pa,*pb;
	pa=a; pb=a+4;
	
	int n=4;
	int *pa=new int[n]; // new int(n) - указатель на целое n (не массив!!!)
	... 
	delete []pa;
	
	do { print(pa, pb);} while (next(pa,pb)); // в районе ...
   
3.	без массивов; за один проход считывания данных: while(cin>>x)
	1) посчитать количество, сумму, среднее, дисперию
	2) значение многочлена и его производной=?
		a.txt: x a_0 ... a_n 
			а) z(x)=sum_0^n(x^p*a_p)
			б) z'(x)=sum_0^n(p*x^(p-1)*a_p)
		a.txt: x a_n ... a_0
			a) ...
			б) ...
	3) алгоритм евклида (НОД)
		а) по заданным a,b найти НОД(a,b)
		б) найти p,q (целые, но м.б. разных знаков), что
			a*p+b*q=1 , где  a,b - простые числа
		в*) при каких a,b алгоритм работает дольше свего?
		г) за какое максимальное кол-во итераций будет поведён алгоритм

4.	1) сделать калькулятор на make (функции mult и plus для файлов)
	1*) входное выражение любое a+b*(c+d)
	2) используя рекурсию:
		а) вычислить факториал
		б) найти числа фиббоначи
		в) определить биномиальные коэффициенты
		г) решить задачу о ханойской башне
		д) найти НОД с помощью бинарного алгоритма Евклида (Таня)
		
5.	1) исправить программу с массивами OurArray
	2) класс combination:
		а) конструируется по кол-ву нолей и единиц,
		б) print распечатывает текущее состояние
		в) next переход в следующее состояние
	3) (X,Y)-> Y=k*X+b -  определить коэфф. с помощью мнк
	4) по примеру ura_ku сделать Makefile, генерирующий программы для калькулятора (+-*/)
	
6.	1) сделать класс 3D вектора:
		а) создание по 3 коррдинатам
		б) вывод в поток
		в) обращение по индексу
		г) умножение на число
		д) сложение
	2) сделать класс permutation набора чисел:
		а) объект класса по его длине (1 2 3 4 5)
		б) вывести в поток
		в) поменять местами два эл-та с заданными индексами
		г) перемножить перестановки = с объектом С последовательно проделать то, что было сделано с А и Б. (С=А*Б)
		д) next - по минимуму увеличивает обект класса за счёт перестановки
		
7,8. 1) сделать класс FFTWMatrix
		а) конструирование по w,h
		б) копирование данных из др. объекта класса
		в) доступ к эл-ту по индексу с преобразованием к complex<double> at(p,q)
	2) FFTWPlan - конструировнаие по двум матрицам, execute
	3) ф-ии load_matrix, save_matrix - сохр. и загрузка в/из картинку через QImage
	4) сделать свёртку двух картинок, записать в третью
	5) Дописать рисование поля и робота
	
9.	1) эмулятор ханойской башни
		а) вводим число букв на шпинделе (3)
		б) cout >> 1) ABC; 2); 3)
		в) вводим 1 2
		г) cout>> 1) AB; 2)C; 3)  //перебросили последний эл-т

10.	1) решатель ханойской башни
	2) ввести слова и вывести их в обратном порядке (list)
	3) сортировка пузырьком для vector, list
	
11.	волк, коза и капуста
	1) pprint(char) - распечатка ситуации
	2) bool valid_state(char) - допустимость состояния
	3) can_go(char,char) - возможность перехода
	4) граф состояний
	5) последовательность действий для переправы