лекция-13

Метод Рунге-Кутта четвёртого порядка
	k1 = dt*f(z_(p), t);            k2 = dt*f(z_(p)+k1/2, t+dt/2);
	k3 = dt*f(z_(p)+k2/2, t+dt/2);  k4 = dt*f(z_(p)+k3, t+dt);
	z_(p+1) = 1/6*(k1+2*k2+2*k3+k4) + z_(p);
	
	проблема: хотим работать с разными функциями
	решения: 1) указатель на ф-ию;
			 2) наследование
			 3) шаблоны
_________________________________________________________________

си-стиль программирование = лаконично, но не очень понятно
while(*(p1++) = *(p2++))

//указатель р2 сдвигается и теперь указывает на второй эл-т массива, но операция * вернёт предыдущее значение, т.е. первый эл-т

с++ ситиль программирования = ... с точностью до наоборот
while(p2) {
	*p1 = *p2;
	++p1;
	++p2
}
__________________________________________________________________

лекция-15

НАСЛЕДОВАНИЕ

Пример:

f(A& transformer) { //ссылка м. указывать на объект класса А и любых производных от него классов
	int x = 1;
	x = transformer.eval(x); //eval относится к производным классам
	cout << x;
}

A1 t1; //class A1 (производный класс) и A связаны отношением наследования
f(t1);
___________

Теория:

class A {
public:
	int eval(int x) {return x+1;}
};

class A1: public A {
public:
	int eval(int x) {return x+2;}
};

Makefile будет выглядеть так:

main: main.o a.o a1.o
	$(CXX) -o $@ $^
main.o: main.cpp a.h a1.h
a.o: a.cpp a.h
a1.o: a1.cpp a1.h

__________________________________________________________________
__________________________________________________________________

Лекция 16.
РЕШЕНИЕ УРАВНЕНИЯ КРИСТОФФЕЛЯ

1)Задача
распространение плоских акустических волн в твёрдом теле
коэф. упругости c_ijkl => скорость волны v ~ sqrt(c/pho)
	Г_ik = c_ijkl*n_i*n_l - тензор кристоффеля
	y = pho*v^2
	(Г - I*y)*q=0 //q - поляризация, I - единичная матрица
	det()=0 => (pho*v^2)_i => q_i
	
симметрия
	cijkl = cjikl = cijlk = cklij
	поэтому
		    (1)  (2)  (3)
		(1)  1    6    5
		(2)  6    2    4   ijkl -> ab
		(3)  5    4    3
		
чтобы перейми в НОВУЮ СИСТЕМУ КООРДИНАТ, нужно ввести матрицу перехода m_ij:
c'_pqrs = c_ijkl * m_pi * m_qi * m_rk * m_sl
m = (x'_x x'_y x'_z
	 y'_x y'_y y'_z
	 y'_x y'_y y'_z)
элементы - проекции новых коорднат на старые
____________________________

2. Решение на С++
	1) vec3 - нормаль
	2) tensor4 - упругие постоянные
	3) mat3 - тензор кристоффеля Г_ik
	4) polynomial - полином для y
	5) solpart - пара скорость-поляризация
	6) util.h util.cpp - объявление и определение внешних функций